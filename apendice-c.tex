\chapter{Código desarrollado}\label{apx:code}

\par La versión organizada por archivos y carpetas se encuentra en el siguiente enlace \url{https://github.com/e-usb/heater}

\par El código usado únicamente para el algoritmo, sin incluir la interfaz, se muestra a continuación.

\section{Ciclo externo}

\begin{verbatim}
const { round, logger, options, unitConv, 
  initSystem, linearApprox, newtonRaphson, 
  viscosityApprox, kw_tubes_A312_TP321
} = require('./js/utils');
const data = require('./data/data.json');
const {radSection} = require('./js/heaterSections/rad');
const {convSection} = require('./js/heaterSections/conv');
const {shieldSection} = require('./js/heaterSections/shield');
const {combSection} = require('./js/heaterSections/combustion');
const {browserProcess} = require('./js/browser');

const createParams = (opts) => {
  const
    m_fluid = unitConv.BPDtolb_h(
      unitConv.lbtokg(opts.mFluid),
      opts.spGrav
    ), // kg/h
    t_in  = opts.tIn, // (K)
    t_out = opts.tOut,// (K)
    miu_fluid_in = opts.miuFluidIn,  // (cp)
    miu_fluid_out= opts.miuFluidOut, // (cp)
    cp_fluid_in  = opts.cpFluidIn, // (kJ/kg-C)
    cp_fluid_out = opts.cpFluidOut,// (kJ/kg-C) 
    kw_fluid_in = unitConv.kwENtokwSI(opts.kwFluidIn), // (kJ/h-m-C)
    kw_fluid_out= unitConv.kwENtokwSI(opts.kwFluidOut);// (kJ/h-m-C)

  return {
    runDistCycle: opts.runDistCycle,
    /** Inlet Amb Variables */
    p_atm:  opts.pAtm,         // (Pa) 
    t_fuel: opts.tFuel,        // (K) 
    t_air:  opts.tAir,         // (K)
    t_amb:  opts.tAmb,         // (K) ref
    humidity:  opts.humidity,  // (%) 
    airExcess: opts.airExcess, // (% *.01) 
    o2Excess:  opts.o2Excess,  // (% *.01) 
    
    /** Process Variables */
    sp_grav:   opts.spGrav, // -
    t_in_conv:  t_in,       // (K) global process inlet
    t_out:      t_out,      // (K) global process outlet
    m_fluid:    m_fluid,    // (kg/h) 
    Rfi:      opts.rfi,     // (h-m2-C/kJ) int. fouling rad
    Rfo:      opts.rfoConv, // (h-m2-C/kJ) ext. fouling cnv
    Rfi_conv: opts.rfiConv, // (h-m2-C/kJ) int. fouling conv sect
    Rfi_shld: opts.rfiShld, // (h-m2-C/kJ) int. fouling shld sect
    Rfo_shld: opts.rfoShld, // (h-m2-C/kJ) ext. fouling shld sect
    efficiency: opts.effcy,         // (% *.01)
    duty_rad_dist: opts.radDist,    // (% *.01)
    heat_loss_percent: opts.hLoss,  // (% *.01)
    max_duty: unitConv.BTUtokJ(71.5276*1e3),// (kJ/h) unused
    miu_fluid: viscosityApprox({
      t1: t_in,  v1: miu_fluid_in,
      t2: t_out, v2: miu_fluid_out
    }),                     // (cP)
    Cp_fluid: linearApprox({
      x1: t_in,  y1: cp_fluid_in,
      x2: t_out, y2: cp_fluid_out
    }),                     // (kJ/kg-C) 
    kw_fluid: linearApprox({
      x1: t_in,  y1: kw_fluid_in,
      x2: t_out, y2: kw_fluid_out
    }),                     // (kJ/h-m-C)
    
    /** Mechanic variables for heater */
    Material: 'A-312 TP321',
    h_conv: unitConv.hcENtohcSI(1.5),// (kJ/h-m2-C)
    kw_tube: kw_tubes_A312_TP321,    // (kJ/h-m-C)
    Pass_number: 2,          // - number of tube passes
    
    Pitch_rad: unitConv.intom(2*8),// (m) NPS * 2
    N_rad:  42,                    // - number of tubes 
    L_rad:  unitConv.fttom(62.094),// (m) tube effective length
    Do_rad: unitConv.intom(8.625), // (m) tube external diameter
    Sch_rad:unitConv.intom(0.322), // (m) Schedule thickness

    Burner_number: 13,            // - burner's number
    Do_Burner:   2.24,            // (ft) burner's outside diameter

    Width_rad:  17.50,            // (ft) width in rad sect
    Length_rad: 64.55,            // (ft) length in rad sect
    Height_rad: 27.00,            // (ft) height in rad sect
    
    N_shld: 16,                   // - number of tubes 
    L_shld: unitConv.fttom(60),   // (m) effective tube length
    Do_shld:unitConv.intom(6.625),// (m) external diameter 
    
    Pitch_sh_cnv: unitConv.intom(2*6),// (m) NPS * 2
    Sch_sh_cnv:  unitConv.intom(0.28),// (m) Schedule thickness
    Tpr_sh_cnv:  8,                   // - number of tubes per row

    N_conv: 40,                   // - number of tubes 
    L_conv: unitConv.fttom(60),   // (m) effective tube length
    Do_conv:unitConv.intom(6.625),// (m) external diameter 

    // Fin properties
    Nf:unitConv.mtoft(60),   // (#/m) Fin's number per meter
    Tf:unitConv.fttom(.005), // (m) Fin's thickness
    Lf:unitConv.fttom(0.08), // (m) Fin's height

    /** Miscellaneous */
    FinType: 'Solid',
    FinMaterial: '11.5-13.5Cr',
    FinArrange: 'Staggered Pitch',
    verbose: opts.verbose,       // True or False
    unitSystem: opts.unitSystem, // SI or English
    lang: opts.lang,             // EN or ES
    NROptions: opts.NROptions,   // {object options}
    units: initSystem(opts.unitSystem)
  }
}

const heaterFunc = (fuels, opts) => {
  const params = createParams(opts);

  // if params.o2Excess is set, start airExcess iteration
  if (params.o2Excess != 0) combustionCycle(params, fuels);

  const heat_result = combSection(params.airExcess, fuels, params);

  if (params.runDistCycle) externalCycle(params);

  heat_result.rad_result = radSection(params);
  heat_result.shld_result = shieldSection(params);
  heat_result.conv_result = convSection(params);
  heat_result.rad_result.eff_thermal_val = 
    heat_result.rad_result.eff_thermal(heat_result.conv_result.Q_stack);
  heat_result.rad_result.eff_gcv_val = 
    heat_result.rad_result.eff_gcv(heat_result.conv_result.Q_stack);

  return heat_result
}

const externalCycle = (params) => {
  // cycle iter count and flag for debugging logs 
  let cycle = 0, noLog = true;
  const rad_dist = (radDist) => {
    cycle++;
    if (radDist >0.3 && radDist <1) {
      params.duty_rad_dist = radDist;
    }
    const int_rlt = {
      rad:  radSection(   params, noLog),
      shld: shieldSection(params, noLog),
      conv: convSection(  params, noLog)
    };
    const duty_calc = Math.abs(int_rlt.rad.Q_fluid) + 
    Math.abs(int_rlt.shld.Q_fluid) + Math.abs(int_rlt.conv.Q_fluid);

    return (params.duty - duty_calc)/duty_calc;
  };
  const convNROptions = {...params.NROptions};
  convNROptions.maxIterations *= 5;
  convNROptions.tolerance *= 1e-1;
  convNROptions.epsilon *= 1e-1;
  convNROptions.h *= 1e-1;
  const rad_dist_final = newtonRaphson(rad_dist, 
    params.duty_rad_dist, convNROptions, 'rad_dist_final');
  if (rad_dist_final >0.1 && rad_dist_final <1) { 
    params.duty_rad_dist = rad_dist_final; 
  } else {
    logger.error('external cycle broken, error in rad_dist estimation, using: '+
    params.duty_rad_dist);
  }
  logger.info(`duty_rad_dist: ${
    round(100*rad_dist_final,2)}, ext_cycle_reps: ${cycle}`);
}

const combustionCycle = (params, fuels) => {
  // cycle iter count and flag for debugging logs 
  let cycle = 0, onlyO2 = true;
  const comb_o2 = (airExcessVal) => {
    cycle++;
    const combO2 = combSection(airExcessVal, fuels, params, onlyO2)
    if (!onlyO2) logger.info( `'O2%_comb': ${combO2.flows['O2_%']}, `+
      `O2excess: ${params.o2Excess *100}`);

    return Math.round(combO2.flows['O2_%']*1e5 -params.o2Excess*1e7);
  }
  const convNROptions = {...params.NROptions};
  convNROptions.maxIterations *= 5;
  convNROptions.tolerance *= 1e-1;
  convNROptions.epsilon *= 1e-1;
  convNROptions.h *= 1e-1;
  const airExcess = newtonRaphson(comb_o2,.05,
    convNROptions, 'o2_excess_to_air');

  if (airExcess) params.airExcess = airExcess;
  logger.info(`'air_excess': ${round(100*airExcess,2)}, `+
    `'comb_cycle_reps': ${cycle}`);
}

let fuelsObject = { 
  H2:     .1142, N2:   .0068, CO:   .0066, CO2: .0254, 
  CH4:    .5647, C2H6: .1515, C3H8: .0622, C4H10: .0176, 
  iC4H10: .0075, C2H4: .0158, C3H6: .0277,
};
// Fuel for debugging purpose
// fuelsObject ={
//   CH4: 1,
//   // H2: .7, O2: .2, N2: .1
// };

/** App entry point */
if (typeof window !== 'undefined') {
  browserProcess(fuelsObject, data, options, heaterFunc)
} else {
  logger.info(JSON.stringify(heaterFunc(fuelsObject, options), null, 2))
}
\end{verbatim}

\subsection{Combustión}
\begin{verbatim}
const { newtonRaphson, options, logger,
  round, roundDict, initSystem,
  normalize, flueViscosity, flueThermalCond
} = require('../utils');
const data = require('../../data/data.json');
const dryAirN2Percentage = 79.05;
const dryAirO2Percentage = 20.95;
const N2O2relation = dryAirN2Percentage/dryAirO2Percentage;
const dryAir = {
  O2: .01 * dryAirO2Percentage,
  N2: .01 * dryAirN2Percentage,
  H2O: 0
};

/** Check if the percentages of the fuels sums 100%.
 * In case of check fail an error will be attached to the result.
*/
const checkObjectFraction = (fuels, result = {}) => {
  const total = Object.values(fuels).reduce((acc, value)=> acc + value)
  const tolerance = 3e-12
  const check1 = Math.abs(1 - total) <= tolerance
  if (!check1) result.err += `[fuel fraction not equal to 1,` + 
    ` total: ${total}. fuels: ${Object.keys(fuels)}],`;
  return check1;
};

/** Check if all the components in the fuels are in the data filtered.
 * In case of a bad fuel entered an error will be attached to the result.
*/
const checkFuelData = (fuels, compounds, result = {}) => {
  const badFuels = Math.abs(compounds.length - 
    Object.keys(fuels).length);
  const check1 = badFuels === 0;
  if (!check1) {
    logger.error(`[some fuels aren't in the database, #badFuels: ${badFuels}],`);
    result.err += `[some fuels aren't in the database, #badFuels: ${badFuels}],`;
  }
  return check1;
};

/** (kJ/kg K) to call returning function use Kelvin units 
  * if you want a result in (kJ/kmol K) units, multiply the
  * result by MW or call this with second argument set to true.
 */
const Cp0 = ({c0, c1, c2, c3, MW, Substance}, molResult, noLog) => {
  // Cp equation from table A.6 Van Wylen
  // Teta = T(Kelvin)
  return (teta) => {
    // Approximate equation valid from 250 K to 1200 K.
    if (teta < 250 && !noLog) logger.debug(`"Cp0", "temp": "${round(teta)}",`+
      `"Msg": "${Substance} bellow range for Cp0 formula"`);
    if (teta > 1200&& !noLog) logger.debug(`"Cp0", "temp": "${round(teta)}",`+
      `"Msg": "${Substance} above range for Cp0 formula"`);
    if (c0 === "-") {
      logger.debug(`"Cp0", "Msg": "Wrong use, called for compound `+
      `${Substance}, no data found"`);
      return 0;
    }
    if (molResult) return MW*(c0 + c1*(teta*.001) + 
        c2*(teta*.001)**2 + c3*(teta*.001)**3)
    return (c0 + c1*(teta*.001) + c2*(teta*.001)**2 + c3*(teta*.001)**3)
  }
};

/** (kJ/kg K) argument needs to be a fuel object,
* ie: { CH4: 0.323, ... }
* if you want a result in (kJ/kmol K) units, call it with 
* second argument set to true.
*/
const Cp_multicomp = (fuels, molResult, noLog) => {
  if (fuels.length === 0) return (_t) => 0
  // making a deep copy and normalize if needed
  let normalFuel = JSON.parse(JSON.stringify(fuels));
  if (!checkObjectFraction(fuels)) 
    normalFuel = normalize(normalFuel, "Cp_multicomp", noLog);
  const fuelComps = data.filter(elem => elem.Formula in normalFuel);
  const cps = [];
  let i = 0;
  for (const fuel in normalFuel) {
    cps[i] = (t) => normalFuel[fuel] * Cp0(
      fuelComps.filter(elem => elem.Formula == fuel)[0], molResult
    )(t);
    i++;
  }
  
  return cps.reduce((acc, val) => ((t) => acc(t) + val(t)), (_t) => 0);
};

/** (kg/kmol) argument needs to be a fuel object,
* ie: { CH4: 0.323, ... }
*/
const MW_multicomp = (fuels, noLog) => {
  if (fuels.length === 0) return (_t) => 0;
  // making a deep copy and normalize if needed
  let normalFuel = JSON.parse(JSON.stringify(fuels));
  if (!checkObjectFraction(fuels)) 
    normalFuel = normalize(normalFuel, "MW_multicomp", noLog);
  const fuelComps = data.filter(elem => elem.Formula in normalFuel);
  let MWs = 0;
  for (const fuel in normalFuel) {
    MWs += fuelComps.filter(elem => elem.Formula == fuel)[0].MW * 
    normalFuel[fuel];
  }
  return MWs;
};

/** (Pa) Temperature should be in K, humidity %[0,100] */
const pressureH2OinAir = (temperature, relativeHumidity) => {
  // Equation from Reference: Tetens, O., 1930

  // This eq uses temp in °C
  const temp = temperature - options.tempToK;
  // ps is the saturation vapour pressure, in pascals,
  const ps = 610.78*Math.exp(temp/(temp+238.3)*17.2694);
  // result pw is the actual water vapour pressure.
  return ps * relativeHumidity * 0.01;
};

/** Temperature should be in K, humidity %[0,100] */
const moistAirWeightRatio = (temperature, relativeHumidity) => {
  const pw = pressureH2OinAir(temperature, relativeHumidity)
  // returned value is the weight ratio of water vapour and dry air.
  // (kg-w_vap/kg-dry_a)
  return data[31].MW * pw / 
  ( MW_multicomp(dryAir) * (options.pAtm - pw ) );
  // a simplification can be: 0.62 * 1e-5 * pw
  
  /* weight ratio converted to water per oxygen in air
  const w = data[31].MW * pw / 
    ( MW_multicomp(dryAir) * (options.pAtm - pw ) );
  return w * 7.655;
  //*/
};

/** (kJ/kmol), Enthalpy of formation plus delta enthalpy 
  * returns a function if no temp is passed */
const deltaH = (compound, t) => {
  if (compound.Cp0 === '-') {
    if (compound.h0 === '-') {
      logger.warn(`wrong use of deltaH func,`+
        ` called for compound ${compound.Substance} without data`);
      if (t === undefined) return () => 0;
      return 0;
    }
    if (t === undefined) return () => compound.h0
    return compound.h0;
  }
  // hf0 + deltaH(tempAmbRef -> t)
  if (t === undefined) return (temp) => compound.h0 +(temp-options.tempAmbRef)*
    Cp0(compound,true, true)((options.tempAmbRef+temp)/2);

  return compound.h0 + (t-options.tempAmbRef)*
    Cp0(compound,true, true)((options.tempAmbRef+t)/2);
};

/** (kJ/kmol), Enthalpy of combustion for a certain compound 
  * returns a function if no temp is passed */
const combustionH = (compound, t, tIni, liquidWater = false) => {
  // hrp = HP - HR // H = H0 + deltaH  // H0 = n(hf)
  // SR ni*(hf + deltaH)i = SP ne*(hf + deltaH)e

  const 
    co2_H = deltaH( data[6]  ),
    so2_H = deltaH( data[34] ),
    o2_H  = deltaH( data[2]  );
  let h2o_H = deltaH(data[31]); // gas lower heating value 
  // higher heating value
  if (liquidWater === true) h2o_H = deltaH(data[32]); // liq
  // making tIni equal to t_amb if not specified
  if (tIni === undefined) tIni = options.tAmb;

  if (t === undefined) return (tempParam) => compound.CO2*co2_H(tempParam) 
    + compound.SO2*so2_H(tempParam) +compound.H2O*h2o_H(tempParam)
    - deltaH(compound)(tIni) - compound.O2*o2_H(tIni);
  
  // SR ni*(hf + deltaH)i = SP ne*(hf + deltaH)e
  return ( compound.CO2*co2_H(t) +compound.SO2*so2_H(t) +compound.H2O*h2o_H(t)
    - deltaH(compound)(tIni) - compound.O2*o2_H(tIni) );
};

/** (kJ/kg) Enthalpy of combustion for a certain fuel mix */
const ncv = (fuels, products, compounds, tAmb, gcv = false) => {
  let value = 0;
  for (const fuel in fuels) {
    if (fuel in products) continue;
    const compound = compounds.filter(elem => elem.Formula == fuel)[0]
    value += fuels[fuel]*combustionH(compound, undefined, tAmb, gcv)(tAmb);
    //logger.info(`H of combustion for ${fuel}: ` +
    // `${combustionH(compound)(tAmb)/compound.MW} KJ/Kg` )
  }
  return value;
};

/**Temp unit (K)
* Internal units (kJ/kmol)
* Function to create the adiabatic flame equation 
* used in the newton raphson method to find adFlame temp */
const adFlame = (normalFuels, products, tIni, o2required) => {
  if (tIni === undefined) tIni = options.tAmb;
  if (o2required === undefined) o2required = 0;
  const 
    fuelCompounds = data.filter(elem => elem.Formula in normalFuels),
    // ..._H = (t) => hf0 + MW * Cp(t_prom) * (t - t_amb)
    o2_H =  deltaH(data.filter(elem => elem.Formula == "O2")[0]),
    n2_H =  deltaH(data.filter(elem => elem.Formula == "N2")[0]),
    co2_H = deltaH(data.filter(elem => elem.Formula == "CO2")[0]),
    h2o_H = deltaH(data.filter(elem => elem.Formula == "H2O")[0]),
    so2_H = deltaH(data.filter(elem => elem.Formula == "SO2")[0]);

  // Products enthalpy at the new temp minus dry air inlet
  const pEnthalpy = (t) => products.O2*o2_H(t) + products.SO2*so2_H(t) +
    products.H2O*h2o_H(t) + products.CO2*co2_H(t) + 
    products.N2*n2_H(t) - products.N2*n2_H(tIni) - o2required*o2_H(tIni);
  
  // Reactants enthalpy (fuel)
  const rEnthalpy = [];
  let i = 0;
  for (const fuel in normalFuels) {
    // fuelFraction * [hf0 + MW * Cp(t_prom) * (tIni - t_amb)]
    rEnthalpy[i] = normalFuels[fuel]*deltaH(
      fuelCompounds.filter(elem => elem.Formula == fuel)[0]
    )(tIni);
    i++;
  }
  
  // SR ni*(hf + deltaH)i = SP ne*(hf + deltaH)e
  return (t) => pEnthalpy(t) - rEnthalpy.reduce((acc, value)=> acc + value);
};

/** For every element in the fuel compounds 
 * calculates every product of combustion per fuel element
 * filling the product object.
*/
const combPerFuelCompound = (compounds, products, normalFuel) => {
  for (const elem of compounds) {
    for (const product in products) {
      if (product == 'N2') {
        if (elem['Formula'] == 'N2' || elem['Formula'] =='"N2a') {
          products[product] += normalFuel[elem['Formula']];
          continue;
        }
        products[product] += elem['O2']*normalFuel[elem['Formula']]*N2O2relation;
        continue;
      }
      products[product] += elem[product]*normalFuel[elem['Formula']];
      // logger.default(`${elem['Formula']} req = ${product} ` +
      //   `${elem[product]*normalFuel[elem['Formula']]}` )
    }
  }
}

/** In this process the params object will be updated
*  in every function call with the combustion data
*/
const combSection = (airExcess, fuels, params, onlyO2) => {
  if (!onlyO2) logger.debug(`"airExcess", "value": ${airExcess}`);
  const units = initSystem(params.unitSystem);
  const moisture_val = moistAirWeightRatio(
    params.t_air, params.humidity
  );
  const debug_data = {
    err: "",
    atmPressure:     units.pressure(params.p_atm),
    fuelTemperature: units.tempC(params.t_fuel,0),
    ambTemperature:  units.tempC(params.t_amb,0),
    airTemperature:  units.tempC(params.t_air,0),
    "humidity_%": params.humidity,
    "dryAirN2_%": round(dryAirN2Percentage,2),
    "dryAirO2_%": round(dryAirO2Percentage,2),
    moisture:   units.moist(moisture_val),
    spGrav: params.sp_grav,
    cpFluidTb: units.cp(params.Cp_fluid((params.t_in_conv + params.t_out) /2)),
    unitSystem: units.system[params.lang]
  };
  const compounds = data.filter((elem, _i, _arr) => elem.Formula in fuels)

  let normalFuel = {...fuels};
  if (!checkObjectFraction(fuels, debug_data)) 
    normalFuel = normalize(fuels, "combSection");
  checkFuelData(normalFuel, compounds, debug_data);

  const products = {O2:0, N2:0, H2O:0, CO2:0, SO2:0}, air = {...dryAir};

  // filling products object with stoichiometric ratio
  combPerFuelCompound(compounds, products, normalFuel);

  // air excess and humidity shouldn't be less than 0
  if (airExcess - 0.000001 < 0) airExcess = 0;
  if (params.humidity - 0.000001 < 0) params.humidity = 0;
  /** Percentage of O2 in excess = 100% + x% airExcess */
  let o2required = products['O2'];
  let o2excess = o2required * (1 + airExcess);
  // If O2 requirements are negative 
  if (products['O2'] <= 0 || products['N2'] < 0) {
    logger.error(`airExcess set to 0, O2 in fuel >= O2 needed.`+
    ` Products: {O2:${products['O2']}, N2:${products['N2']}}`);
    o2excess   = 0;
    o2required = 0;
    products['N2'] = normalFuel['N2'];
    products['O2'] = -products['O2'];
  } else {
    const 
      waterPressure  = pressureH2OinAir(params.t_air, params.humidity),
      dryAirPressure = params.p_atm - waterPressure;
    air.N2  = .01* dryAirN2Percentage* dryAirPressure / params.p_atm;
    air.O2  = .01* dryAirO2Percentage* dryAirPressure / params.p_atm;
    air.H2O = waterPressure / params.p_atm;
    
    debug_data.dryAirPressure = units.pressure(dryAirPressure);
    debug_data.waterPressure  = units.pressure(waterPressure);
    debug_data["H2OPressure_%"] = round(100 * air.H2O);
    debug_data["N2Pressure_%"]  = round(100 * air.N2);
    debug_data["O2Pressure_%"]  = round(100 *air.O2);

    products['O2'] = o2excess -products['O2']; // Subs O2 used in combustion
    products['N2']  += products['O2']*(air.N2/air.O2);
    products['H2O'] += products['N2']*(waterPressure/(air.N2*params.p_atm));
  }

  let totalPerMol = 0, totalPerM_Dry = 0;
  for (const product in products) {
    totalPerMol += products[product];
    if (product !== 'H2O') totalPerM_Dry += products[product];
  }
  const flows = {
    total_flow: totalPerMol,
    dry_total_flow: totalPerM_Dry,
    // 'O2%_DRY': 100*products['O2'] /totalPerM_Dry,
    // 'CO2%_DRY':100*products['CO2']/totalPerM_Dry,
    // 'N2%_DRY': 100*products['N2'] /totalPerM_Dry,
    'N2_%': 100*products['N2'] /totalPerMol,
    'H2O_%':100*products['H2O']/totalPerMol,
    'CO2_%':100*products['CO2']/totalPerMol,
    'O2_%': 100*products['O2'] /totalPerMol,
    
    moisture_val,

    O2_mol_req_theor: o2required,
    O2_mass_req_theor:units.mass(o2required * data[2].MW),
    'air_excess_%':   100 * params.airExcess,
    AC:               o2excess / air.O2,
    AC_theor_dryAir:  o2required / (.01 * dryAirO2Percentage),
    AC_mass:          o2excess / air.O2 * 
      MW_multicomp(air)/MW_multicomp(normalFuel),
    AC_mass_theor_moistAir: o2required / air.O2 * 
      MW_multicomp(air)/MW_multicomp(normalFuel),

    fuel_MW: MW_multicomp(normalFuel),
    Cp_fuel: Cp_multicomp(normalFuel),

    flue_MW: MW_multicomp(products,onlyO2),
    Cp_flue: Cp_multicomp(products,false,onlyO2)
  };

  if (onlyO2) return {flows, products, debug_data};

  /** Adding results in parameters to be used in following sections */

  params.m_flue_ratio = totalPerMol * flows.flue_MW/MW_multicomp(normalFuel);  
  // kg/h
  params.m_air_ratio  = o2excess / air.O2 *
  MW_multicomp(air)/MW_multicomp(normalFuel); // kg/h

  params.Pco2 = products['CO2']/totalPerMol; // fraction
  params.Ph2o = products['H2O']/totalPerMol; // fraction

  // Functions of temp (kJ/kg-K)
  params.Cp_air  = Cp_multicomp(air);
  params.Cp_fuel = Cp_multicomp(normalFuel);
  params.Cp_flue = flows.Cp_flue;
  params.miu_flue= flueViscosity( data, products );
  params.kw_flue = flueThermalCond(data, products);
  flows.Cp_fuel_val  = flows.Cp_fuel(params.t_fuel);
  flows.Cp_fuel  = units.cp(flows.Cp_fuel_val);
  flows.Cp_flue  = units.cp(flows.Cp_flue(params.t_air));
  flows.flue_MW  = units["mass/mol"](flows.flue_MW);

  params.NCV = -ncv(normalFuel, products, compounds, params.t_amb)/
  MW_multicomp(normalFuel); // kJ/kg
  params.GCV = -ncv(normalFuel, products, compounds, params.t_amb, true)/
  MW_multicomp(normalFuel); // kJ/kg
  flows.NCV = units["energy/mass"](params.NCV,0);
  flows.GCV = units["energy/mass"](params.GCV,0);
  flows.NCV_val = params.NCV;
  flows.GCV_val = params.GCV;

  params.adFlame = newtonRaphson(
    adFlame(normalFuel, products, params.t_amb, o2excess),
    2000, params.NROptions, "fuel_adFlame");
  logger.info( `Adiabatic flame temp: [${round(params.adFlame)} K]`+
    ` ${units.tempC(params.adFlame)}`);

  roundDict(products);
  if (debug_data.err == "") delete debug_data.err;
  return {flows, products, debug_data};
};

module.exports = {
  combSection
};
\end{verbatim}

\subsection{Zona Radiante}
\begin{verbatim}
const {newtonRaphson, logger, round, unitConv} = require('../utils');

/** radSection receives the parameters dictionary and
 * calculates the required mass fluid or the necessary
 * temperature change at the radiant section.
 * 
 * First assumption to start the calc is duty transferred
 * in radiant section = 70% of total duty
 * 
 * Q_in = Q_rls + Q_air + Q_fuel =
 * Q_out = Q_R + Q_shield + Q_losses + Q_flue
 * Q_in(tg_out) - Q_out(tg_out) ~= 0
 * 
 * Q_rad + Q_conv = Q_R = Q_fluid(out-in)
*/
const radSection = (params, noLog) => {
  /** There are two starting cases A & B
   * Case A: given the fluid temp at the exit point of heater.
   * Case B: given the flow mass of the fuel at the heater burners. 
   * */
  let 
    tg_out = 0, // (K) Leaving/effective gas temp
    t_in   = 0, // (K) Inlet fluid temp
    t_out  = params.t_out,  // (K) Outlet fluid temp
    m_fuel = params.m_fuel; // (kg/h)

  let 
    duty_total  = 0, // (kJ/h) Duty in the hole fired heater
    duty_rad = 0; // (kJ/h) Duty in the radiant section
  
  const // Temperatures
    t_air     = params.t_air,    // (K) Inlet air temp
    t_fuel    = params.t_fuel,   // (K) Inlet fuel temp
    t_amb     = params.t_amb,    // (K) Ambient temp
    t_in_conv = params.t_in_conv,// (K) Heater inlet fluid temp
    /** (K) bulk temp (second arg default to rad inlet fluid temp) */
    Tb = (tOut, tIn = t_in) => 0.5*(tIn + tOut);

  const // Fired heater parameters
    Rfi = params.Rfi,      // (h-m2-C/kJ) internal fouling factor
    N = params.N_rad,      // (-) number of tubes in rad sect
    N_shld = params.N_shld,// (-) number of tubes in shld sect
    L = params.L_rad,      // (m) effective tube length
    L_shld = params.L_shld,// (m) effective tube length
    Do = params.Do_rad,    // (m) external diameter rad section
    Di = params.Do_rad - params.Sch_rad,// (m) int diameter rad sect
    S_tube = params.Pitch_rad || 0.394, // (m) center to center distance of tube
    S_tube_shld = params.Pitch_sh_cnv,    // (m) center to center distance of tube
    h_conv = params.h_conv || 30.66, 
    // (kJ/h-m2-C) Film convective heat transfer coff

    /** (ft) Mean Beam Length, dim ratio 1-2-1 to 1-2-4*/
    MBL = (2/3)*(params.Width_rad*params.Length_rad*params.Height_rad)**(1/3),
    PL  = (params.Ph2o + params.Pco2) * MBL, // atm-ft
    alpha = 1 +.49*(S_tube/Do)/6 -.09275*(S_tube/Do)**2 +
        .065*(S_tube/Do)**3/6 +.00025*(S_tube/Do)**4,
    alpha_shld =  1, // (-) alpha shield factor
    
    At = N *Math.PI *Do *L, // (m2) Bank tube's external surface area
    Acp = N * S_tube * L,   // (m2) Cold plane area of radiant tube bank
    Acp_shld = N_shld/2 *S_tube_shld*L_shld, 
    // (m2) Cold plane area of shield tube bank
    Ar = Ar_calc(params),   // (m2) Total refractory area
    {Aw, Aw_aAcp} = Aw_calc(alpha, Acp, alpha_shld, Acp_shld, Ar), // (m2)
    Ai = Math.PI*(Di**2)/2, // (m2) Tube's inside flux area x2
    cnv_fact = 3_600 *1e-3, // (g/s -> kg/h) secondsToHours * 1/k

    sigma = 5.670374e-8 *cnv_fact, // (W/m2-K4) -> (kJ/h-m2-K4)
    F = (temp) => effectivity(
        PL, alpha, Acp, alpha_shld, Acp_shld, Ar)(unitConv.KtoF(temp));

  const // Process Variables
    duty_rad_dist = params.duty_rad_dist         || .7,   // (-) % *.01
    efficiency = params.efficiency               || .8,   // (-) % *.01
    heat_loss_percent = params.heat_loss_percent || .015, // (-) % *.01
    NCV = params.NCV, // (kJ/kg) net calorific value
    GCV = params.GCV, // (kJ/kg) net calorific value
    m_fluid= params.m_fluid, // (kg/h) Fluid mass flow
    m_air  = (mFuel = m_fuel) => params.m_air_ratio*mFuel, // (kg/h) Air mass flow
    m_flue = (mFuel = m_fuel) => params.m_flue_ratio*mFuel,// (kg/h) Flue mass flow
    Cp_fuel = params.Cp_fuel(Tb(t_fuel, t_amb)), // (kJ/kg.K) Fuel mass heat
    Cp_air  = params.Cp_air( Tb(t_air, t_amb) ), // (kJ/kg.K) Air mass heat
    Cp_fluid = (tIn,tOut=tIn) => params.Cp_fluid(Tb(tIn, tOut)), // (kJ/kg.K)
    Cp_flue  = (tG,tG_out=tG) => params.Cp_flue(Tb(tG, tG_out)), // (kJ/kg.K)
    kw_fluid = (temp) => params.kw_fluid(temp),
    // (kJ/h-m-C) fluid thermal conductivity
    kw_tube  = (temp) => params.kw_tube(temp), 
    // (kJ/h-m-C - J/s-m-C-3.6) tube thermal conductivity
    miu_fluid= (temp) =>params.miu_fluid(temp),//(cP - g/m-s) fluid Viscosity
    G = (m_fluid/cnv_fact) /Ai, // Fluid mass speed inside radiant tubes
    prandtl = (t) => miu_fluid(t)*Cp_fluid(t)*cnv_fact/kw_fluid(t), // (miu*Cp/kw)
    reynolds = (t) => G * Di/miu_fluid(t); // (-) G*Di/miu
  
  const 
    /** (kJ/h-m2-C) internal heat transfer coff */
    hi = (tB,tW = tB) => .023 *(kw_fluid(tB) /Di) *reynolds(tB)**.8 *
      prandtl(tB)**(1/3) *(miu_fluid(tB)/miu_fluid(tW))**.14,
    /** Average tube wall temp (K) */
    Tw = (tB, tW = tB, dutyRad = duty_rad) => (dutyRad/At) *(Do/Di)* 
      (Rfi +1/hi(tB,tW) +(Di*Math.log(Do/Di)/(2*kw_tube(tW))) ) +tB;

  const // ******* Heat input to the radiant section ********
    Q_air    = (mFuel) => m_air(mFuel) *Cp_air *(t_air -t_amb), 
    // Sensible heat of air
    Q_fuel   = (mFuel) => mFuel * Cp_fuel*(t_fuel -t_amb), // Sensible heat of fuel
    Q_rls    = (mFuel) => mFuel * NCV, // Combustion heat of fuel
    Q_in     = (mFuel) => Q_rls(mFuel) + Q_air(mFuel) + Q_fuel(mFuel), // Heat input
    Q_rls_gcv= (mFuel) => mFuel * GCV, 
    // Combustion heat of fuel with liquid water out
    Q_in_gcv = (mFuel) => Q_rls_gcv(mFuel) + Q_air(mFuel) + Q_fuel(mFuel); 
    // Heat input
  
  const // ******* Heat taken out of radiant section ********
    Q_flue = (tG, mFuel) => m_flue(mFuel)*Cp_flue(tG,t_amb)*(tG-t_amb), 
    // Flue gases's sensible heat 
    Q_losses = (mFuel) => Q_rls(mFuel) *heat_loss_percent,    
    // Heat losses through setting
    Q_conv = (tG, tW) => h_conv * At * (tG - tW),             
    // Convective heat transfer
    Q_rad  = (tG, tW) => F(tG)*sigma*alpha*Acp*(tG**4-tW**4), 
    // Radiant heat transfer
    Q_shld = (tG, tW) => F(tG)*sigma*alpha_shld*Acp_shld*(tG**4-tW**4), 
    // Shld_rad heat transfer
    Q_R = (tG, tW) => Q_rad(tG,tW) + Q_conv(tG,tW), 
    // Heat absorbed by radiant tubes
    Q_out = (tG, mFuel=m_fuel, tW = Tw(Tb(t_out), Tw(Tb(t_out)))) => 
    Q_R(tG, tW) + Q_shld(tG, tW) + Q_losses(mFuel) + Q_flue(tG, mFuel);

  const Q_fluid = (tOut, tIn) => m_fluid*Cp_fluid(tIn,tOut)*(tOut -tIn); 
  // Fluid's sensible heat

  // **************************************************

  /* Calculating tg_out the option missing from given variables 
  (mass_fuel or temp_out) */

  if (t_out !== 0) { // Given temp_out
    duty_total = Q_fluid(t_out,t_in_conv); // Duty effective from t_out
    duty_rad = duty_total * duty_rad_dist; 
    // Calculate Tw with seed from 30-70 duty distribution
    // Approximating t_in_rad with assumption from duty distribution
    t_in = t_in_conv + 
      duty_total*(1 -duty_rad_dist)/(m_fluid*Cp_fluid(t_in_conv,t_out));

    // Calculating tg_out (effective gas temp)
    const tg_out_func = (tG) => Q_fluid(t_out,t_in) -
      Q_R(tG,Tw(Tb(t_out),Tw(Tb(t_out))));
    const flame = newtonRaphson(tg_out_func, 1000, 
      params.NROptions, "Tg_Tout-seed_radiant", noLog);
    if (flame) tg_out = flame;

    // Calculating fuel mass
    const m_fuel_func = (mFuel) => Q_in(mFuel) -
      Q_out(tg_out,mFuel,Tw(Tb(t_out),Tw(Tb(t_out))));
    let mass_fuel_seed = Q_fluid(t_out,t_in_conv) /(NCV*efficiency);
    if (!noLog) logger.debug(`"mass_fuel_seed", "value": "${mass_fuel_seed}"`);
    mass_fuel_seed = newtonRaphson(m_fuel_func, mass_fuel_seed,
      params.NROptions, "M-fuel_T-seed_radiant", noLog);
    if (mass_fuel_seed) m_fuel = mass_fuel_seed;

    duty_rad = Q_R(tg_out,Tw( Tb(t_out), Tw(Tb(t_out)) ));

  } else { // Given mass_fuel
    duty_total = Q_rls(m_fuel) *efficiency; 
    // Duty effective from from q release by fuel
    duty_rad = duty_total *duty_rad_dist; 
    // Calculate Tw with seed from 30-70 duty distribution
    // Approximating t_in_rad and t_out with efficiency and duty dist
    t_in = t_in_conv + duty_total*(1 -duty_rad_dist) /(m_fluid*Cp_fluid(t_in_conv));
    let t_out_seed = t_in_conv + duty_total /(m_fluid*Cp_fluid(t_in));

    // Calculating tg_out (effective gas temp)
    const tg_out_func = (tG) => Q_in(m_fuel) -
    Q_out(tG,m_fuel,Tw(Tb(t_out_seed),Tw(Tb(t_out_seed))));
    const flame = newtonRaphson(tg_out_func, 1000, 
      params.NROptions, "Tg_mFuel-seed_radiant", noLog);
    if (flame) tg_out = flame;

    // Calculating t_out 
    const t_out_func = (tOut) => Q_fluid(tOut,t_in) -
        Q_R(tg_out,Tw(Tb(tOut),Tw(Tb(tOut))));

    t_out_seed = newtonRaphson(t_out_func, t_out_seed, 
      params.NROptions, "Tout_mFuel-seed_radiant", noLog);
    if (t_out_seed) t_out = t_out_seed;

    // TODO: recalculation let t_out_recall = t_in - t_out + (Q_rad(tg_out) + 
    // Q_conv(tg_out)) / (m_fluid*Cp_fluid(t_in,t_out))
    const duty_recalculated = m_fluid*Cp_fluid(t_in,t_out)*(t_out -t_in_conv);
    const t_in_recalculated = params.t_in_conv + 
    duty_recalculated*(1 -duty_rad_dist)/(m_fluid*Cp_fluid(t_in,t_out));  
    // Discrepancies on recalculation
    if (!noLog) logger.info(`t_out, seed: ${t_out_seed} vs calc: ${t_out}`);
    if (!noLog) logger.info(`t_in_rad, seed: ${
        t_in} vs calc: ${t_in_recalculated}`);
  }

  // **************************************************
  if (!noLog) logger.default(`RADI, T_in_calc: ${params.units.tempC(t_in)},`+
    ` M_fuel: ${
    params.units.mass_flow(m_fuel)}, Tg_out: ${params.units.tempC(tg_out)}`);

  params.t_in_rad = t_in;
  params.t_out    = t_out;
  params.tg_rad   = tg_out;
  params.duty     = duty_total;
  params.m_flue   = m_flue(m_fuel);
  params.m_air    = m_air(m_fuel);
  params.t_w_rad  = Tw( Tb(t_out), Tw(Tb(t_out)) );
  params.q_rad_sh = Q_shld(tg_out, params.t_w_rad);

  const rad_result = {
    m_air:    m_air(),
    m_flue:   m_flue(),
    m_fuel:   m_fuel,
    m_fluid:  m_fluid,
    t_in:     t_in,
    t_out:    t_out,
    Tw:       params.t_w_rad,
    tg_out:   tg_out,

    rfi:      Rfi,

    Q_in:     Q_in(m_fuel),
    Q_rls:    Q_rls(m_fuel),
    Q_air:    Q_air(m_fuel),
    Q_fuel:   Q_fuel(m_fuel),
    
    Q_out:    Q_out(tg_out, m_fuel),
    Q_flue:   Q_flue(tg_out, m_fuel),
    Q_losses: Q_losses(m_fuel),
    Q_shld:   Q_shld(tg_out, params.t_w_rad ),
    Q_conv:   Q_conv(tg_out, params.t_w_rad ),
    Q_rad:    Q_rad( tg_out, params.t_w_rad ),

    Q_R:      Q_R(tg_out, params.t_w_rad),
    Q_fluid:  Q_fluid(t_out,t_in),

    At:       At,
    Ar:       Ar,
    Ai:       Ai,
    Aw:       Aw,
    Aw_aAcp:  Aw_aAcp,
    Acp:      Acp,
    aAcp:     alpha*Acp,
    Acp_sh:   Acp_shld,

    hi:       hi( Tb(t_out), params.t_w_rad ),
    h_conv:   h_conv,

    duty_total: duty_total,
    duty:       duty_rad,
    "%":        duty_rad/duty_total,
    eff_total:  duty_total/Q_rls(m_fuel) > 1 ? 100 : 100*duty_total/Q_rls(m_fuel),
    eff_thermal:(Q_stack)=>100 *(Q_in(m_fuel) - Q_losses(m_fuel) - Q_stack) /
      Q_in(m_fuel),
    eff_gcv:    (Q_stack)=>100 *(Q_in(m_fuel) - Q_losses(m_fuel) - Q_stack) /
      Q_in_gcv(m_fuel),
    duty_flux:  duty_rad/At,

    Alpha:    alpha,
    MBL:      round(MBL),
    Pco2:     round(params.Pco2),
    Ph2o:     round(params.Ph2o),
    PL:       round(PL),
    F:        round(F(tg_out)),
    emiss:    round(emissivity(PL)(tg_out)),

    kw_tube:  kw_tube(Tw(Tb(t_in))),
    kw_fluid: kw_fluid(Tb(t_in)),
    kw_flue:  params.kw_flue(tg_out),

    Cp_fluid: Cp_fluid(t_in,t_out),
    Cp_flue:  Cp_flue(tg_out,t_amb),
    Cp_fuel:  Cp_fuel,
    Cp_air:   Cp_air,

    Prandtl:  round(prandtl(Tb(t_out))),
    Reynolds: round(reynolds(Tb(t_out))),

    TUBING: {
      Material: params.Material,
      Nt:       2,
      N:        N,
      Sch:      params.Sch_rad,
      Do:       Do,
      L:        L,
      S_tube:   S_tube
    },
    
    FINING: "None"
  }
  rad_result.miu_flue = params.miu_flue(tg_out);
  rad_result.miu_fluid = miu_fluid(Tb(t_out));
  
  return rad_result
}

/** returns emissivity(temp) function of temperature to calculate F */
const emissivity = (pl) => {
  // constants to calculate emissivity(temp) from PL
  const constants = {
    a: { A:  2.58e-08, B: -3.90e-08, C:  6.80e-09, D: -2.20e-10},
    b: { A: -1.19e-04, B:  5.60e-05, C: -4.10e-06, D: -7.20e-07},
    c: { A:  0.212580, B:  0.225800, C: -0.047351, D:  0.004165}
  };

  const factors = (factor, constant = constants) => {
    return ((temp) => 
    constant.a[factor]*temp**2 + 
    constant.b[factor]*temp + constant.c[factor]);
  };

  const 
    A = factors("A"),
    B = factors("B"),
    C = factors("C"),
    D = factors("D");

  return (temp) => A(temp) + B(temp)*pl + C(temp)*pl**2 + D(temp)*pl**3;
};

/** (m2) parameters must be in ft */
const Ar_calc = (prams) => {
  const
    ExitArea = unitConv.m2toft2(prams.Pitch_sh_cnv*prams.Tpr_sh_cnv*prams.L_shld),
    Base       = prams.Length_rad * prams.Width_rad,
    WallWidth  = prams.Height_rad * prams.Width_rad,
    WallLength = prams.Height_rad * prams.Length_rad,
    WidthConv   = unitConv.mtoft(prams.Pitch_sh_cnv * prams.Tpr_sh_cnv),
    RoofDeclined_X = (prams.Width_rad - WidthConv)/2,
    RoofDeclined_Z = unitConv.mtoft( 4 * prams.Pitch_rad ),
    RoofDeclined_Y = Math.sin( Math.acos(RoofDeclined_X/RoofDeclined_Z) ) *
      RoofDeclined_Z,
    RoofDeclined   = 2*RoofDeclined_X*RoofDeclined_Y + 2*WidthConv*RoofDeclined_Y,
    Burners = 13 * (Math.PI/4)*2.24**2;
    
  const Ar  = 2*WallWidth + 2*WallLength + 
    2*Base - ExitArea - RoofDeclined - Burners;
  return unitConv.ft2tom2(Ar);
};

/** returns {Aw (m2), Aw_aAcp (-)} */
const Aw_calc = (alpha, Acp, a_shld, Acp_shld, Ar) => {
  const Total_Acp = a_shld*Acp_shld + alpha*Acp; // Equivalent cp area
  const Aw = Ar - Total_Acp; // Effective refractory area
  const Aw_aAcp = Aw / Total_Acp;
  return {Aw, Aw_aAcp};
}
/** returns effectivity(temp) function of temperature to use as F */
const effectivity = (pl, alpha, Acp, a_shld, Acp_shld, Ar) => {
  const {Aw_aAcp} = Aw_calc(alpha, Acp, a_shld, Acp_shld, Ar);
  const emiss = emissivity(pl);
  // logger.warn(`{"Aw (ft)": ${unitConv.m2toft2(Aw)},"Aw_aAcp (-)": ${Aw_aAcp}}`);

  // constants to calculate effectivity(temp) from Aw/aAcp
  const constants = {
    a: { A: -0.0005, B:  0.0072, C: -0.0062 },
    b: { A:  0.0022, B: -0.1195, C:  0.1168 },
    c: { A:  0.0713, B:  0.5333, C: -0.6473 },
    d: { A: -0.0152, B:  1.0577, C: -0.1540 }
  };

  const factors = (factor, constant = constants) => {
    return ((Aw_a_Acp) => 
    constant.a[factor]*Aw_a_Acp**3 + 
    constant.b[factor]*Aw_a_Acp**2 + 
    constant.c[factor]*Aw_a_Acp + constant.d[factor]);
  };

  const 
    A = factors("A"),
    B = factors("B"),
    C = factors("C");
  // log logger.debug(`"Aw/aAcp", "value": "${round(Aw_aAcp)}",`+
  // ` "A": "${round(A(Aw_aAcp))}", "B": "${round(B(Aw_aAcp))}",`+
  // ` "C": "${round(C(Aw_aAcp))}"`);

  return (temp) => A(Aw_aAcp) + B(Aw_aAcp)*emiss(temp) + C(Aw_aAcp)*emiss(temp)**2;
};

module.exports = {
  radSection
};
\end{verbatim}

\subsection{Zona Escudo}
\begin{verbatim}
const {newtonRaphson, logger, LMTD, round} = require('../utils');

const shieldSection = (params, noLog) => {
  let // Temperatures declaration
    tg_in = params.tg_rad,  // (K) Inlet flue gases temp.
    tg_out = 0,             // (K) Outlet flue gases temp.
    t_out = params.t_in_rad,// (K) Outlet fluid temp going to rad sect.

    // --- First estimation: duty equal to the one coming from convect sect
    t_in = (params.t_in_rad + params.t_in_conv)*0.5, // (K) Inlet fluid temp.
    t_in_calc = 0;  // (K) Recalculation for Inlet shld fluid temp.

  /** (K) bulk temp func (second arg default to shld outlet fluid temp) */
  const Tb = (tIn, tOut = t_out) => 0.5*(tIn + tOut);

  const // Process Variables
    m_fluid  = params.m_fluid, // (kg/h) Fluid mass flow.
    m_flue   = params.m_flue,  // (kg/h) Flue mass flow.
    Cp_fluid = (tIn,tOut=tIn) => params.Cp_fluid(Tb(tIn, tOut)), // (kJ/kg.K).
    Cp_flue  = (tG,tG_out=tG) => params.Cp_flue(Tb(tG, tG_out)), // (kJ/kg.K).
    kw_fluid = (temp) => params.kw_fluid(temp),// (kJ/h-m-C) fluid thermal cndct.
    kw_tube  = (temp) => params.kw_tube(temp),
    // (kJ/h-m-C ->J/s-m-C-3.6) tube thermal cndct.
    kw_flue  = (temp) => params.kw_flue(temp),// (kJ/h-m-C) flue thermal cndct.
    miu_fluid= (temp) => params.miu_fluid(temp),//(cP - g/m-s) fluid Viscosity.
    miu_flue = (temp) => params.miu_flue(temp); //(cP - g/m-s) flue Viscosity.

  const // Parameters
    Rfo = params.Rfo_shld,// (h-m2-C/kJ) external fouling factor.
    Rfi = params.Rfi_shld,// (h-m2-C/kJ) internal fouling factor.
    N  = params.N_shld, // - number of shld tubes.
    L  = params.L_shld, // (m) effective tube length.
    Do = params.Do_shld,// (m) external diameter shld section.
    Di = params.Do_shld - params.Sch_sh_cnv*2,// (m) int diameter shld sect.
    S_tube = params.Pitch_sh_cnv, // (m) Tube spacing.

    At = N *Math.PI *Do *L,   
    // (m2) Area of tubes in bank, total outside surface area, m2
    Ai = Math.PI *(Di**2) /2, // (m2) Inside tube surface area, m2
    An = N/2 *(S_tube -Do)*L, // Free area for flue flow at shld sect
    
    cnv_fact = 3_600 * 1e-3; // (g/s -> kg/h) secondsToHours * 1/k.

  const // Process Functions
    prandtl = (t) => miu_fluid(t)*cnv_fact *
      Cp_fluid(t)/kw_fluid(t),// (-) miu*Cp/kw.
    prandtl_flue = (t)=> miu_flue(t)*cnv_fact*
      Cp_flue(t)/kw_flue(t),  // (-) miu_fle*Cp_flue/kw_flue.
    G = (m_fluid/cnv_fact) /Ai, // Fluid mass flow per area unit inside tubes.
    reynolds = (t) => G * Di/miu_fluid(t), // (-) G*Di/miu.
    Gn = (m_flue/cnv_fact) /An, 
    // Gn it's the mass speed based on the free area for the gas flow.
    reynolds_flue = (t) => Gn * Do/miu_flue(t), // (-) Gn*Do/miu_flue.
      
    /** (kJ/m²h-°C) internal heat transfer coff */
    hi = (tB, tW = tB) => .023 *(kw_fluid(tB) /Di) *reynolds(tB)**.8 *
      prandtl(tB)**(1/3)*(miu_fluid(tB)/miu_fluid(tW))**.14,
    /** (kJ/m²h-°C) effective radiative coff wall tube */
    hr = (tG_b) => .092 * tG_b - 34,
    /** (kJ/m²h-°C) * film heat transfer coff */
    hc = (tG_b) => .33 *(kw_flue(tG_b) /Do) *
      prandtl_flue(tG_b)**(1/3) *reynolds_flue(tG_b)**.6,
    /** (kJ/m²h-°C) external heat transfer coff */
    ho = (tG_out, tG_in = tg_in) => 1/(1/(hc(Tb(tG_out, tG_in)) + 
      hr(Tb(tG_out, tG_in))) +Rfo);
  
  const
    duty_sh = (tIn) => m_fluid *Cp_fluid(tIn) *(t_out -tIn),
    /** Average tube wall temp (K) */
    Tw = (tB, tW = tB, tIn = t_in) => (duty_sh(tIn)/At) *(Do/Di)*
      (Rfi +1/hi(tB,tW) +(Di *Math.log(Do/Di) /(2*kw_tube(tW))) ) +tB;

  const // Thermal Resistances (hr-ft2-F/Btu)
    R_int = (tB, tW) => Do / (Di * hi(tB,tW)) + (Do/Di)*Rfi, // Inside
    R_tube= (tW) => Do * Math.log(Do/Di) / (2*kw_tube(tW)),  // Tube wall
    R_ext = (tG_out, tG_in = tg_in) => 1/ho(tG_out, tG_in),  // Outside
    
    R_sum = (tG_out, tG_in, tB, tW) => 
      R_ext(tG_out, tG_in) + R_tube(tW) + R_int(tB,tW),
    Uo  = (tG_out, tG_in, tB, tW) => 1 / R_sum(tG_out, tG_in, tB, tW);
  
  const Q_rad = params.q_rad_sh; 
    // (kJ/h) Q_rad = sigma*(alpha*Acp)*F*(Tg**4 - Tw**4)
  /** Q_conv = Uo . Ao . LMTD */
  const Q_conv = (tIn, tG_in, tG_out, tB, tW) => 
    Uo(tG_out, tG_in, tB, tW)*At*LMTD(tIn, t_out, tG_in, tG_out)
  /** Q_R = Q_conv + Q_rad */
  const Q_R = (tIn, tG_in, tG_out, tB, tW) => Q_rad + 
    Q_conv(tIn, tG_in, tG_out, tB, tW);
  /** Q_fluid =  M . Cp . deltaT */
  const Q_fluid = (tIn, tOut = t_out) => m_fluid * 
    Cp_fluid(tIn, tOut) * (tOut - tIn);
  /** Q_flue =  M . Cp . deltaT */
  const Q_flue = (tG_in,tG_out=tg_out) => m_flue * 
    Cp_flue(tG_in, tG_out) * (tG_in - tG_out);
  
  const tg_out_func = (tG_out) => Q_flue(tg_in, tG_out) + 
    Q_rad - Q_fluid(t_in, t_out);
  const Tin_sh_func = (tIn) => Q_fluid(tIn) - 
    Q_R(tIn, tg_in, tg_out, Tb(tIn), Tw( Tb(tIn),Tw(Tb(tIn)) ));
  // -------- 1st estimation of tg_out   #.#.#.#.#
  tg_out = newtonRaphson(tg_out_func, 
    (tg_in - 100), params.NROptions, "Tg_out_shield-1",noLog);
  t_in_calc = newtonRaphson(Tin_sh_func, 
    t_in, params.NROptions, "T_in_shield-1",noLog);

  let iter = 1;
  const 
    normalized_error = 1e-3, // 0.1%
    normalized_diff = (tG_out) => Math.abs((Q_flue(tg_in, tG_out) -
      Q_conv(t_in,tg_in,tG_out,Tb(t_in),Tw(Tb(t_in),Tw(Tb(t_in)))) )/ 
        Q_flue(tg_in, tg_out));
  while (normalized_diff(tg_out) - normalized_error > 0) {
    if (t_in_calc) { t_in = t_in_calc; } else {
      logger.error("Invalid t_in_calc at shield sect");
      break;
    }
    
    t_in_calc = newtonRaphson(Tin_sh_func, 
      t_in, params.NROptions, "T_in_shield-2",true);
    tg_out = newtonRaphson(tg_out_func, 
      (tg_in - 58), params.NROptions, "Tg_out_shield-2",true);

    // Forced break of loop
    iter++;
    if (iter > 35) {
      logger.debug(`"Tin_shield",  "t_in_sh_calc": ${
        round(t_in_calc)}, "t_in_sh_sup": ${round(t_in)}`);
      if (!noLog) logger.info(
        `diff vs error: ${normalized_diff(tg_out)}-${normalized_error}`);
      logger.error("Max iterations reached for inlet temp calc at shield sect");
      break;
    }
  }
  
  if (!noLog) logger.default(
    `SHLD, cycles: ${iter}, T_in_calc: ${params.units.tempC(t_in)}, `+
    `Tg_out: ${params.units.tempC(tg_out)}`)

  params.t_in_sh = t_in;
  params.tg_sh = tg_out;

  return {
    m_flue:   m_flue,
    t_in_sup: (params.t_in_rad + params.t_in_conv)*0.5,
    t_in:     t_in,
    t_out:    t_out,
    Tb:       Tb(t_in),
    Tw:       Tw( Tb(t_in), Tw(Tb(t_in)) ),
    tg_out:   tg_out,
    tg_in:    tg_in,
    Tb_g:     Tb(tg_in, tg_out),
    LMTD:     LMTD(t_in, t_out, tg_in, tg_out),
    DeltaA:   (tg_in - t_out),
    DeltaB:   (tg_out - t_in),

    rfi:          Rfi,
    rfo:          Rfo,

    Q_flue:   Q_flue(tg_in, tg_out),
    Q_fluid:  Q_fluid(t_in),
    Q_R:      Q_R( t_in, tg_in, tg_out, Tb(t_in), Tw(Tb(t_in)) ),
    Q_rad:    Q_rad,
    Q_conv:   Q_conv( t_in, tg_in, tg_out, Tb(t_in), Tw(Tb(t_in)) ),

    Cp_fluid:   Cp_fluid(t_in,t_out),
    Cp_flue:    Cp_flue(tg_in,tg_out),
    miu_fluid:  miu_fluid(Tw(Tb(t_in))),
    miu_flue:   miu_flue(tg_out),

    duty:       duty_sh(t_in),
    "%":        duty_sh(t_in)/params.duty,
    duty_flux:  duty_sh(t_in)/At,

    kw_fluid:   kw_fluid(Tb(t_in)),
    kw_tube:    kw_tube(Tw(Tb(t_in))),
    kw_flue:    kw_flue(Tb(tg_in, tg_out)),

    Prandtl:    round(prandtl(Tb(t_out))),
    Reynolds:   round(reynolds(Tb(t_out))),
    PrandtlFlue: round(prandtl_flue(Tb(t_out))),
    ReynoldsFlue:round(reynolds_flue(Tb(t_out))),

    At:       At,
    Ai:       Ai,
    An:       An,
    Gn:       Gn,

    hi:         hi( Tb(t_in) ),
    hi_tw:      hi( Tb(t_in), Tw(Tb(t_in)) ),
    hr:         hr(tg_in),
    ho:         ho(tg_out),
    hc:         hc( Tb(tg_in, tg_out) ),

    Uo:         Uo(tg_out, tg_in, Tb(t_in), Tw( Tb(t_in),Tw(Tb(t_in)) ) ),
    R_int:      R_int( Tb(t_in), Tw( Tb(t_in),Tw(Tb(t_in)) ) ),
    R_tube:     R_tube( Tw( Tb(t_in),Tw(Tb(t_in)) ) ),
    R_ext:      R_ext(tg_out, tg_in),

    TUBING: {
      Material: params.Material,
      Nt:       params.Tpr_sh_cnv,
      N:        N,
      Sch:      params.Sch_sh_cnv,
      Do:       Do,
      L:        L,
      S_tube:   S_tube
    },
    
    FINING: "None"
  };
}

module.exports = {
  shieldSection
};
\end{verbatim}

\subsection{Zona Convectiva}
\begin{verbatim}
const {logger, LMTD, round} = require('../utils');

const convSection = (params, noLog) => {
  let
    tg_in  = params.tg_sh,  // (K) Inlet gas temp coming from shld sect
    tg_out = 0,             // (K) Outlet gas temp
    t_out  = params.t_in_sh,// (K) Outlet fluid temp going to shld sect

    // --- First estimation: t_in equal to the one given
    t_in   = params.t_in_conv, // (K) Inlet process fluid temp
    t_in_calc = 0;  // (K) Recalculation for Inlet process fluid temp

  /** (K) bulk temp func (second arg default to conv outlet fluid temp) */
  const Tb = (tIn, tOut = t_out) => 0.5*(tIn + tOut);

  const // Process Variables
    m_fluid  = params.m_fluid, // (kg/h) Fluid mass flow
    m_flue   = params.m_flue,  // (kg/h) Flue mass flow
    Cp_fluid = (tIn,tOut=tIn) => params.Cp_fluid(Tb(tIn, tOut)), // (kJ/kg.K)
    Cp_flue  = (tG,tG_out=tG) => params.Cp_flue(Tb(tG, tG_out)), // (kJ/kg.K)
    kw_fluid = (temp) => params.kw_fluid(temp),
    //(kJ/h-m-C - J/s-m-C-3.6) fluid thermal conductivity
    kw_tube  = (temp) => params.kw_tube(temp),
    // (kJ/h-m-C ->J/s-m-C-3.6) tube thermal cndct
    kw_flue  = (temp) => params.kw_flue(temp),// (kJ/h-m-C) flue thermal cndct
    miu_fluid= (temp) =>params.miu_fluid(temp),//(cP - g/m-s) fluid Viscosity
    miu_flue = (temp) => params.miu_flue(temp);//(cP - g/m-s) flue Viscosity

  const // Parameters
    Rfo = params.Rfo, // (h-m2-C/kJ) external fouling factor
    Rfi = params.Rfi_conv,// (h-m2-C/kJ) internal fouling factor
    L  = params.L_conv, // (m) effective tube length
    Do = params.Do_conv,// (m) external diameter conv section
    Di = params.Do_conv - params.Sch_sh_cnv*2,// (m) int diameter conv sect
    S_tube = params.Pitch_sh_cnv, // (m) Tube spacing, 2*NPS
    N  = params.N_conv,        // (-) number of tubes convective sect
    N_tpr = params.Tpr_sh_cnv, // (-) Number of tube wide
    N_f = params.Nf,           // (1/m) Fin's number per meter
    L_fin = params.Lf,         // (m) Fin's height
    Th_fin = params.Tf,        // (m) Fin's thickness
    Ad = N_tpr*S_tube*L,       // Cross sectional area of box
    Ac = Do+2*L_fin*Th_fin*N_f,// Fin tube cross sectional area/ft, ft2/ft
    An  = Ad - Ac*L*N_tpr,     // Free area for flue flow
    Apo = Math.PI*Do*(1-N_f*Th_fin), // (m2) Outside prime tube surface area, m2/m
    Ao  = Math.PI*Do*(1-N_f*Th_fin) +
      Math.PI*N_f*(2*L_fin*(Do +L_fin) +Th_fin*(Do +2*L_fin)),
    Afo = Ao - Apo,            // (m2) Fin outside surface area, m2/m
    At  = N * Ao * L,          // (m2) Total outside surface area, m2/m
    Ai  = Math.PI *(Di**2) /2, // (m2) Inside tube surface area, m2/m

    /** (ft) Mean Beam Length, dim ratio 1-2-1 to 1-2-4*/
    MBL = 2/3 * (params.Width_rad*params.Length_rad*params.Height_rad) **(1/3),
    PL = (params.Ph2o + params.Pco2) * MBL, // PP*MBL

    cnv_fact = 3_600 * 1e-3; // (g/s -> kg/h) secondsToHours * 1/k

  const // Process Functions
    prandtl = (t) => miu_fluid(t)*cnv_fact *Cp_fluid(t)/kw_fluid(t),// (-) miu*Cp/kw
    prandtl_flue = (t)=> miu_flue(t)*cnv_fact*Cp_flue(t)/kw_flue(t),// (-)
    G = (m_fluid/cnv_fact) /Ai, // Fluid mass flow per area unit inside tubes
    reynolds = (t) => G * Di/miu_fluid(t), // (-) G*Di/miu
    Gn = m_flue/An, // mass speed based on the free area for the gas flow
    reynolds_flue = (t) => Gn/cnv_fact *Do/miu_flue(t), // (-) G*Di/miu
    /** (kJ/m²h-°C) internal heat transfer coff */
    hi = (tB, tW = tB) => .023 *(kw_fluid(tB) /Di) *reynolds(tB)**.8 *
      prandtl(tB)**(1/3) *(miu_fluid(tB)/miu_fluid(tW))**.14;

  /** Q_fluid = M *Cp *deltaT */
  const Q_fluid = (tIn, tOut =t_out) => m_fluid *Cp_fluid(tIn, tOut) *(tOut -tIn);
  const duty_conv = (tIn) => Q_fluid(tIn);  
  // Duty in convective sect used for Tw calc

  /** Tw = Average tube wall temperature in Kelvin degrees */
  const Tw = (tB = Tb(t_out, t_in) , tW = tB, tIn = t_in) => (duty_conv(tIn) /At) *
    (Do/Di) *( Rfi +1/hi(tB,tW) +( Di *Math.log(Do/Di) /(2*kw_tube(tW)) ) ) +tB;

  const
    gr = (_tB, _tW) => 2.6*(0.29307107*cnv_fact), 
    // (Btu/hr-ft2-F) Outside radiation factor //HACK: Find implementation
    hr = (tG_b, tW) => 2.2 *gr(tG_b, tW) *(PL)**.50 *(Apo/Ao)**.75; 
    // (kJ/m²h-°C) effective radiative coff wall tube

  let hc = (tG_b, _tW) => .33 *(kw_flue(tG_b)/Do) *
    prandtl_flue(tG_b)**(1/3) *reynolds_flue(tG_b)**.6; // (kJ/m²h-°C)

  const
    ho = (tG_b, tW) => 1/( 1/(hc(tG_b, tW) +hr(tG_b,tW)) +Rfo ), 
    // (kJ/m²h-°C) external heat transfer coff
    /** Fin's Efficiency */
    Kw_fin = 1.36* kw_tube(Tw(Tb(t_in,t_out), Tw(Tb(t_in,t_out)))),
    B = L_fin + (Th_fin /2),
    m = (ho(Tb(tg_in,tg_out), Tw(Tb(t_in,t_out), Tw(Tb(t_in,t_out)))) / 
      (6 * Kw_fin * Th_fin))**0.5,
    x = Math.tanh(m * B) / (m * B),
    y = x * (0.7 + 0.3 * x),
    Df = Do + 2*L_fin,
    Ef  = y * (0.45 * Math.log(Df / Do) * (y - 1) + 1),    // (-) Fin efficiency
    he = (tG_b, tW) => ho(tG_b, tW) *(Ef*Afo + Apo) / Ao,  // (kJ/m²h-°C)
    j = (tG_b, tW) => colburnFactor(reynolds_flue, params, m, B)(tG_b, tW);  
    // Colburn factor

  hc = (tG_b, tW) => j(tG_b, tW) *Gn *Cp_flue(tG_b) *prandtl_flue(tG_b)**(-.67); 
  // (kJ/m²h-°C) film heat transfer coff

  /** LMTD counter-current */
  const LMTD_Tin = (tIn) => LMTD(tIn, t_out, tg_in, tg_out);

  const // Thermal Resistances (hr-ft2-F/Btu)
    R_int = (tB, tW) => Do/Di * (1/hi(tB, tW) + Rfi),         // Inside
    R_tube =  (tW)  => Do * Math.log(Do/Di) / (2*kw_tube(tW)),// Tube wall
    R_ext = (tG_b, tW) => 1/he(tG_b, tW),                     // Outside

    R_sum = (tG_b, tB, tW) => R_ext(tG_b, tW) + R_tube(tW) + R_int(tB,tW),
    Uo  = (tG_b, tB, tW) => 1 / R_sum(tG_b, tB, tW);


  /** Q_flue  = M *Cp *deltaT */
  const Q_flue = (tG_in, tG_out) => m_flue*Cp_flue(tG_in,tG_out) *(tG_in -tG_out);

  /** Q_conv = Uo * Ao *LMTD */
  const Q_conv = (tIn, tG_in, tG_out) =>
    Uo( Tb(tG_out, tG_in), Tb(tIn), Tw(Tb(tIn),Tw(Tb(tIn))) ) *At *LMTD_Tin(tIn);

  const tg_out_func = (tIn, tG_out = tg_in*0.7) => tg_in - Q_fluid(tIn) /
    (m_flue * Cp_flue(Tb(tg_in,tG_out)));
  const err_diff = () => 100 *( Q_conv(t_in_calc, tg_in, tg_out) -
    Q_fluid(t_in_calc) ) /Q_fluid(t_in_calc);
  const err_tol_pass = () => Math.abs(err_diff()) < 0.001
  
  // -------- 1st estimation of tg_out   #.#.#.#.#
  tg_out = tg_out_func(t_in);
  t_in_calc = t_in;

  while ((tg_out - t_in_calc) < 0) {
    t_in_calc *= 1.002;
    tg_out = tg_out_func(t_in_calc);
  }

  let min, max;

  for (let iter = 0; iter < 100; iter++) {
    if (err_tol_pass()) {
      break
    }
    if ((tg_out - t_in_calc) < 0 || err_diff() <= 0) {
      min = t_in_calc;
      if (min && max) {
        t_in_calc = (min + max)/2
      } else {
        t_in_calc *= 1.001
      }
    } else {
      max = t_in_calc;
      if (min && max) {
        t_in_calc = (min + max)/2
      } else {
        t_in_calc *= 0.999
      }
    }
    tg_out = tg_out_func(t_in_calc);
  }
  
  t_in = t_in_calc;

  if (!noLog) logger.default(`CONV, T_in_calc: ${params.units.tempC(t_in_calc)}, ` +
    `T_in_given: ${params.units.tempC(params.t_in_conv)}, ` +
    `Tg_stack: ${params.units.tempC(tg_out)}`);

  params.t_in_conv_calc = t_in;
  params.tg_conv = tg_out;

  return {
    t_fin:        params.Ts( Tb(t_in), Tw( Tb(t_in), Tw(Tb(t_in)) )),
    t_fin_max:    t_out + Q_conv( t_in, tg_in, tg_out)/
      (At/(params.N_conv/ params.Tpr_sh_cnv)) *(Do/Di) 
      *( Rfi +1/hi(Tb(t_in),Tw( Tb(t_in), Tw(Tb(t_in)) )) +
      ( Di *Math.log(Do/Di) /(2*kw_tube(Tw( Tb(t_in), Tw(Tb(t_in)) ))) ) ),
    t_in_given:   params.t_in_conv,
    t_in:         t_in,
    t_out:        t_out,
    Tb:           Tb(t_in),
    Tw:           Tw( Tb(t_in), Tw(Tb(t_in)) ),
    tg_out:       tg_out,
    tg_in:        tg_in,
    Tb_g:         Tb(tg_in, tg_out),

    rfi:          Rfi,
    rfo:          Rfo,

    LMTD:         LMTD_Tin(t_in),
    DeltaA:       (tg_in - t_out),
    DeltaB:       (tg_out - t_in),

    Q_flue:       Q_flue( tg_in, tg_out),
    Q_fluid:      Q_fluid(t_in),
    Q_conv:       Q_conv( t_in, tg_in, tg_out),
    Q_stack:      Q_flue( tg_out, params.t_air),

    duty:         Q_fluid(t_in),
    "%":          Q_fluid(t_in)/params.duty,
    duty_flux:    Q_fluid(t_in)/At,

    Cp_fluid:     Cp_fluid( t_in, t_out   ),
    Cp_flue:      Cp_flue(  tg_in, tg_out ),
    miu_fluid:    miu_fluid(Tw(Tb(t_in))  ) ,
    miu_flue:     miu_flue( tg_out        ),
    kw_fluid:     kw_fluid( Tb(t_in)      ),
    kw_tube:      kw_tube(  Tw(Tb(t_in))  ),
    kw_fin:       Kw_fin,
    kw_flue:      kw_flue(  Tb(tg_in, tg_out)),

    Prandtl:      round(prandtl(Tb(t_out))),
    Reynolds:     round(reynolds(Tb(t_out))),
    PrandtlFlue:  round(prandtl_flue(Tb(t_out))),
    ReynoldsFlue: round(reynolds_flue(Tb(t_out))),

    At:     At,
    Ai:     Ai,
    An:     An,
    Ao :    Ao,
    Apo:    Apo,
    Afo:    Afo,
    Ef :    Ef,
    Gn:     Gn/cnv_fact,

    hi:     hi( Tb(t_in),          Tw(Tb(t_in), Tw(Tb(t_in))) ),
    hr:     hr( Tb(tg_in, tg_out), Tw(Tb(t_in), Tw(Tb(t_in))) ),
    ho:     ho( Tb(tg_in, tg_out), Tw(Tb(t_in), Tw(Tb(t_in))) ),
    hc:     hc( Tb(tg_in, tg_out), Tw(Tb(t_in), Tw(Tb(t_in))) ),
    he:     he( Tb(tg_in, tg_out), Tw(Tb(t_in), Tw(Tb(t_in))) ),
    j:      j(  Tb(tg_in, tg_out), Tw(Tb(t_in), Tw(Tb(t_in))) ),
    gr:     gr( Tb(tg_in, tg_out), Tw(Tb(t_in), Tw(Tb(t_in))) ),

    Uo:     Uo( Tb(tg_in, tg_out), Tb(t_in), Tw(Tb(t_in)) ),
    R_int:  R_int(                 Tb(t_in), Tw(Tb(t_in))),
    R_tube: R_tube(                          Tw(Tb(t_in))),
    R_ext:  R_ext(Tb(tg_in, tg_out),         Tw(Tb(t_in))),

    TUBING: {
      Material: params.Material,
      Nt:       N_tpr,
      N:        N,
      Sch:      params.Sch_sh_cnv,
      Do:       Do,
      L:        L,
      S_tube:   S_tube
    },
    FINING: {
      Material:    params.FinMaterial,
      Type:        params.FinType,
      Height:      params.Lf,
      Thickness:   params.Tf,
      Dens:        params.Nf,
      Arrange:     params.FinArrange
    }
  };
}

const colburnFactor = (reynoldsFlue, parm, m, B) => {
  const
    C1 = (tB_g) => .25 *reynoldsFlue(tB_g)**(-.35), // Reynolds number correction

    Lf = parm.Lf,                         // (m) Fins height
    Sf = 1/parm.Nf - parm.Tf,             // (m) Fin spacing
    C3 = .35 +.65 * Math.exp(-.25*Lf/Sf), 
    // Geometry correction (Solid, staggered pattern)

    Pl = parm.Pitch_sh_cnv,            // (m) Longitudinal tube pitch
    Pt = parm.Pitch_sh_cnv,            // (m) Transverse tube pitch
    Nr = parm.N_conv/ parm.Tpr_sh_cnv, // (-) Tube row's number
    C5 = .7 + (.7 -.8 *Math.exp(-.15*Nr**2)) *Math.exp(-Pl/Pt), 
    // Non-equilateral & row correction

    Df_Do = (2*parm.Lf + parm.Do_conv) / (parm.Do_conv), 
    // (m) Ratio fin's Do per tube's Do

    Ts = (tB_g, tW) => tB_g + (tW - tB_g) / ( ( Math.exp(1.4142*m*B) + 
      Math.exp(-1.4142*m*B) )/2 );// (K) Average fin temp
  parm.Ts = Ts;
  return (tB_g, tW) => C1(tB_g) *C3 *C5 *(Df_Do)**.5 *(tB_g/Ts(tB_g, tW))**.25;
};

module.exports = {
  convSection
};
\end{verbatim}

\section{Funciones compartidas y valores por defecto}
\begin{verbatim}
const logByLevel = (...stringsList) => {
  let finalText = "" + stringsList[1][0]
  for (let i = 1; i < stringsList[1].length; i++) {
    finalText += " " + stringsList[1][i]
  }
  switch (stringsList[0]) {
    case "DEBUG":
      if (options.verbose) 
        console.debug(JSON.parse(`{"${stringsList[0]}": ${finalText}}`));
      break;
    case "INFO": 
      console.info( `%c${stringsList[0]}`,'color: lime;', `'${finalText}'`,);
      break;
    case "ERROR":
      console.error(`%c${stringsList[0]}`,'color: tomato;', `'${finalText}'`,);
      break;
    case "WARN":
      console.warn( `%c${stringsList[0]}`,'color: magenta;', `'${finalText}'`,);
      break;
    default:
      console.log(  `%c${stringsList[0]}`,'color: dodgerblue;', `'${finalText}'`,);
      break;
  }
};
const logger = {
  info:   (...stringsList) => logByLevel("INFO", stringsList),
  warn:   (...stringsList) => logByLevel("WARN", stringsList),
  error:  (...stringsList) => logByLevel("ERROR", stringsList),
  debug:  (...stringsList) => logByLevel("DEBUG", stringsList),
  default:(...stringsList) => logByLevel("DEFAULT", stringsList),
};

/** Receives a function, optional the derivate, a seed and the options object, 
 * finally an identifier name */
const newtonRaphson = (f, fp, x0, nrOptions, name, noLog) => {
  let x1, y, yp, iter, yph, ymh, yp2h, ym2h;

  // Interpret variadic forms:
  if (typeof fp !== 'function') {
    noLog = name;
    name = nrOptions;
    nrOptions = x0;
    x0 = fp;
    fp = null;
  }

  const 
    opts = nrOptions || {},
    tol = opts.tolerance === undefined ? 1e-7 : opts.tolerance,
    eps = opts.epsilon === undefined ? 2.22e-15 : opts.epsilon,
    h = opts.h === undefined ? 1e-4 : opts.h,
    hr = 1 / h,
    maxIter = opts.maxIterations === undefined ? 20 : opts.maxIterations;

  iter = 0;
  while (iter++ < maxIter) {
    // Compute the value of the function:
    y = f(x0);

    if (fp) {
      yp = fp(x0);
    } else {
      // Needs numerical derivatives:
      yph = f(x0 + h);
      ymh = f(x0 - h);
      yp2h = f(x0 + 2 * h);
      ym2h = f(x0 - 2 * h);

      yp = ((ym2h - yp2h) + 8 * (yph - ymh)) * hr / 12;
    }

    // Check for badly conditioned update 
    // (extremely small first deriv relative to function):
    if (Math.abs(yp) <= eps * Math.abs(y)) {
      logger.error(`Newton-Raphson (${
        name}): failed to converged due to nearly zero first derivative`);
      return false;
    }

    // Update the guess:
    x1 = x0 - y / yp;

    // Check for convergence:
    if (Math.abs(x1 - x0) <= tol * Math.abs(x1)) {
      if (!noLog) logger.debug(`"Newton-Raphson", "func":"${name}",`+
        ` "var_converged_to":"${x1}", "iterations":"${iter}"`);
      return x1;
    }

    // Transfer update to the new guess:
    x0 = x1;
  }
  logger.error(`Newton-Raphson (${
    name}): Maximum iterations reached (${maxIter})`);

  return false;
};

const 
  tempToK = 273.15,
  pAtmRef = 101_325,
  /* ATT: Changes here must be done at webInput too. */
  barrelsToft3 = 5.6145833333,
  ft3Tolb = 62.371, // for Water @60°F
  spGrav = 0.84, // for current fluid
  tempAmbRef = tempToK + 15.55556; // 288.7 K

const unitConv = {
  RtoK: (n=1) => n*(5/9),
  KtoR: (n=1) => n*(9/5),
  KtoF: (n=1) => n*(9/5) - 459.67,
  KtoC: (n=1) => n-tempToK,
  CtoK: (n=1) => n+tempToK,
  CtoF: (n=1) => n*(9/5) + 32,
  FtoC: (n=1) => (n-32)*(5/9),
  FtoK: (n=1) => (n-32)*(5/9)+tempToK,

  kgtolb: (n=1) => n*2.20462,
  lbtokg: (n=1) => n/2.20462,
  m3ToBarrels: (n=1) => n/(0.158987295),
  BarrelsTom3: (n=1) => n*(0.158987295),
  BPDtolb_h:(n=1,spG=spGrav) => n*barrelsToft3*ft3Tolb/24*spG,
  lb_htoBPD:(n=1,spG=spGrav) => n/barrelsToft3/ft3Tolb*24/spG,

  kJtoBTU: (n=1) => n/1.05506,
  BTUtokJ: (n=1) => n*1.05506,

  fttom:  (n=1) => n/3.28084,
  ft2tom2:(n=1) => n/(3.28084**2),
  mtoft:  (n=1) => n*3.28084,
  m2toft2:(n=1) => n*(3.28084**2),
  intom:  (n=1) => n/39.3701,
  mtoin:  (n=1) => n*39.3701,

  CpENtoCpSI: (n=1) => n*1.05506/(5/9)*2.20462,     // (kJ/kg-C)
  kwENtokwSI: (n=1) => n*1.05506/(5/9)*3.28084,     // (kJ/h-m-C)
  RfENtoRfSI: (n=1) => n/(1.05506/(5/9)*3.28084**2),// (h-m2-C/kJ)
  hcENtohcSI: (n=1) => n*1.05506/(5/9)*3.28084**2,  // (kJ/h-m2-C)
  BtuHtoW: (n=1) => n/3.4121416331,
};

/** Example call from terminal: node . false ENGLISH 26.6667 50 0 20 1.01325e5 */ 
const getOptions = () => {
  const optObject = {
    // constants
    tempToK,
    tempAmbRef,
    pAtmRef,
    spGrav,

    // Entry default arguments
    runDistCycle: true,     // boolean
    verbose:    true,       // boolean
    tAmb:       tempAmbRef, // K
    tAir:       tempAmbRef, // K
    tFuel:      tempAmbRef, // K
    humidity:   50.0,       // %
    o2Excess:   .01 * 0,    // fr
    airExcess:  .01 * 20,   // fr
    radDist:    .01 * 64,   // % *.01
    hLoss:      .01 * 1.5,  // % *.01
    effcy:      .01 * 80,   // % *.01
    rfi:        0.000,      // hr.ft².°F/Btu
    rfiConv:    0.000,      // hr.ft².°F/Btu
    rfoConv:    0.000,      // hr.ft².°F/Btu
    rfiShld:    0.000,      // hr.ft².°F/Btu
    rfoShld:    0.000,      // hr.ft².°F/Btu
    tIn:        unitConv.FtoK(678),// K
    tOut:       unitConv.FtoK(772),// K
    mFluid:     90e3,       // BPD
    miuFluidIn: 1.45,       // cp
    miuFluidOut:.960,       // cp
    cpFluidIn:  unitConv.CpENtoCpSI(.676), // kJ/kg-C
    cpFluidOut: unitConv.CpENtoCpSI(.702), // kJ/kg-C 
    kwFluidIn:  .038,       // Btu/h-ft-F
    kwFluidOut: .035,       // Btu/h-ft-F
    pAtm:       pAtmRef,    // Pa
    unitSystem: "SI",       // string SI or EN
    lang:       "en",       // string EN or ES
    title:      "base",     // string
    graphVar:   "t_out",    // string one of four
    graphRange: 50,         // uInt
    graphPoints:100,        // uInt
  
    // Newton Raphson arguments
    NROptions: {
      tolerance: 1e-4,
      epsilon: 3e-8,
      maxIterations: 20,
      h: 1e-4,
      verbose: true
    }
  };
  
  if (typeof process == 'undefined') return optObject;

  optObject.verbose =                process.argv[2] == "true";
  optObject.unitSystem =             process.argv[3];
  optObject.tAmb =tempToK+parseFloat(process.argv[4]) || tempAmbRef;
  optObject.humidity =    parseFloat(process.argv[5]) || 0;
  optObject.o2Excess =.01*parseFloat(process.argv[6]) || .01 * 0;
  optObject.airExcess=.01*parseFloat(process.argv[7]) || .01 * 0;
  optObject.pAtm =        parseFloat(process.argv[8]) || 1.01325e5;
  // Newton Raphson arguments
  optObject.NROptions.verbose =      process.argv[2] == "true";

  return optObject;
};
const options = getOptions();
if (options.verbose) 
  logger.debug(`"options","args":${JSON.stringify(options, null, 2)}`);

const round = (number, dec = 3) => number !== undefined ? 
  (number).toLocaleString(
    undefined,
    {minimumFractionDigits: dec, maximumFractionDigits: dec}
  ) : NaN;
const roundDict = (object = {}) => {
  for (const [key, value] of Object.entries(object)) {
    if(!isNaN(value) && value !== "") object[key] = round(value);
  }
};

/** Normalize an object of fuels/products */
const normalize = (fuels, name, noLog) => {
  const normalFuel = {...fuels};
  const total = Object.values(normalFuel).reduce((acc, value)=> acc + value);
  for (const fuel in normalFuel) {
    normalFuel[fuel] = normalFuel[fuel]/total;
  }
  if (!noLog) 
    logger.debug(`"normalize", "name": "${name}", "total": ${total}`);
  return normalFuel;
};

/** Thermal Cond equation func(temp [K]) for certain substance in data */
const kw = ({k0, k1, k2, Substance}) => {
  // Thermal Cond equation from NIST data with polynomial approx. R2=1
  // k2*T^2 + k1*T + k0  (valid from 300K to 1350K)* SO2 only to 500K
  if (k0 == 0 || k0 == "-") {
    logger.debug(`"Thermal Cond func called for '${Substance}' without coffs"`);
    return () => 0;
  }
  const cnv_fact = 3_600 * 1e-3; // Therm. Cond. (W/m*K) -> (kJ/h*m*K)
  return (temp) => (k0 + k1* temp + k2* temp**2)*cnv_fact;
};

/** returns a Thermal Cond function of temp for certain flue composition.
 * 
 * Should be called in the combustion section after flue composition 
 * is determined.
*/
const flueThermalCond = (data, flue) => {
  const 
    normalFlue = normalize(flue, "flueThermalCond"),
    so2_kw = kw(data[34]),
    h2o_kw = kw(data[31]),
    co2_kw = kw(data[6] ),
    n2_kw  = kw(data[3] ),
    o2_kw  = kw(data[2] );

  return (t) => normalFlue.CO2*co2_kw(t) + normalFlue.SO2*so2_kw(t)
  + normalFlue.H2O*h2o_kw(t) + normalFlue.O2*o2_kw(t) + normalFlue.N2*n2_kw(t);
};

/** Viscosity equation func(temp [K]) for certain substance in data */
const miu = ({u0, u1, u2, Substance}) => {
  // Viscosity equation from NIST data with polynomial approx. R2=0.99998
  // u2*T^2 + u1*T + u0  (valid from 300K to 1350K)* SO2 only to 500K
  if (u0 == 0 || u0 == "-") {
    logger.debug(`"Viscosity func called for '${Substance}' without coffs"`);
    return () => 0;
  }
  return (temp) => u0 + u1* temp + u2* temp**2;
};

/** returns a Viscosity function of temp for certain flue composition.
 * 
 * Should be called in the combustion section after flue composition 
 * is determined.
*/
const flueViscosity = (data, flue) => {
  const 
    normalFlue = normalize(flue, "flueViscosity"),
    so2_v = miu(data[34]),
    h2o_v = miu(data[31]),
    co2_v = miu(data[6] ),
    n2_v  = miu(data[3] ),
    o2_v  = miu(data[2] );

  return (t) => normalFlue.CO2*co2_v(t) + normalFlue.SO2*so2_v(t)
  + normalFlue.H2O*h2o_v(t) + normalFlue.O2*o2_v(t) + normalFlue.N2*n2_v(t);
};

/** returns a Thermal conductivity function of temp for tubes A312‐TP321 
 * temp should be used in Kelvin, value returned in (kJ/h-m-C)
*/
const kw_tubes_A312_TP321 = (t) => {
  const 
    temp = t - tempToK, // transforms temp from Kelvin to Celsius
    conv_factor = 3_600 * 1e-3, // (J/s -> kJ/h)
    c0 = 14.643,
    c1 = 1.64e-2,
    c2 = -2e-6;

  return (c0 + c1*temp + c2*temp**2)*conv_factor;
};

/** Returns a linear function f(x)=y to approximate the value,
 * in case that the value is constant or there isn't data
 * about the changes, it can be called with only "y1"
 * to make a function that always return y1.
 */
const linearApprox = ({x1,x2,y1,y2}) => {
  if (typeof y1 !== "number") {
    logger.error(`call for linearApprox with incorrect value type for y1: ${y1}`)
    return () => 0;
  }
  if (x1 == x2 || x2 == undefined || y2 == undefined) 
    return () => y1;
  const m = (y2 - y1) / (x2 - x1);
  return (x) => m * (x - x1) + y1;
};

const viscosityApprox = ({t1,t2,v1,v2}) => {
  if (typeof v1 !== "number") {
    logger.error(`call for viscosityApprox with incorrect value type for v1: ${v1}`)
    return () => 0;
  }
  if (t1 == t2 || t2 == undefined || v2 == undefined) 
    return () => v1;
  const B = Math.log(v1/v2) / (1/t1 - 1/t2)
  const A = v1 * Math.exp(-B/t1);
  return (temp) => A * Math.exp(B/temp);
}

/** (Tref1, Tref2, T1, T2, co-current) Returns the value of the
 * Logarithmic mean temperature difference.
 * 
 * counter-current by default, for co-current set the five argument as true.
 * */
const LMTD = (t_cold_in, t_cold_out, t_hot_in, t_hot_out, co_current) => {
  
  let // counter-current (default)
    delta_t1 = t_hot_in - t_cold_out,
    delta_t2 = t_hot_out - t_cold_in;
    
  if (co_current) { // co-current
    delta_t1 = t_hot_out - t_cold_in;
    delta_t2 = t_hot_in - t_cold_out;
  }
    
  // ( (t_hot_in - t_cold_out) - (t_hot_out - t_cold_in) ) 
  // / ln( (t_hot_in - t_cold_out) / (t_hot_out-t_cold_in) )
  return Math.abs((delta_t1 - delta_t2) /Math.log(Math.abs(delta_t1/delta_t2)));
};

const dualSystem = (onlyUnit, noUnit, decimal=3 ,units="", number=0) => {
  if (onlyUnit) return ` ${units}`;
  return round(number, decimal) + (noUnit ? "" : ` ${units}`);
}

const englishSystem = { //(US Customary)
  "energy/mol":   (n,d,nU,oU) => dualSystem(oU,nU,d,"Btu/mol", unitConv.kJtoBTU(n)),
  "mass/mol":     (n,d,nU,oU) => dualSystem(oU,nU,d,"lb/lbmol", n),
  heat_flow :     (n,d,nU,oU) => dualSystem(oU,nU,d,"MMBtu/h", 
    unitConv.kJtoBTU(n)*1e-6),
  heat_flux:      (n,d,nU,oU) => dualSystem(oU,nU,d,"Btu/h-ft²",
    unitConv.kJtoBTU(n) /unitConv.m2toft2()),
  fouling_factor: (n,d,nU,oU) => dualSystem(oU,nU,d,"h-ft²-°F/Btu", 
    unitConv.m2toft2(n)*unitConv.KtoR()/unitConv.kJtoBTU()),
  "energy/mass":  (n,d,nU,oU) => dualSystem(oU,nU,d,"Btu/lb", 
    unitConv.kJtoBTU(n) / unitConv.kgtolb()),
  "energy/vol":   (n,d,nU,oU) => dualSystem(oU,nU,d,"Btu/ft³", 
    unitConv.kJtoBTU(n) / unitConv.mtoft()**3),

  area:     (n,d,nU,oU) => dualSystem(oU,nU,d,"ft²", unitConv.m2toft2(n)),
  length:   (n,d,nU,oU) => dualSystem(oU,nU,d,"ft", unitConv.mtoft(n)),
  lengthC:  (n,d,nU,oU) => dualSystem(oU,nU,d,"in", unitConv.mtoin(n)),
  lengthInv:(n,d,nU,oU) => dualSystem(oU,nU,d,"1/ft",n/unitConv.mtoft()),
  temp:     (n,d,nU,oU) => dualSystem(oU,nU,d,"°R", unitConv.KtoR(n)),
  tempC:    (n,d,nU,oU) => dualSystem(oU,nU,d,"°F", unitConv.CtoF(n-tempToK)),
  pressure: (n,d,nU,oU) => dualSystem(oU,nU,d,"psi", n *1.450377e-4),
  mass:     (n,d,nU,oU) => dualSystem(oU,nU,d,"lb", unitConv.kgtolb(n)),
  mass_flow:(n,_d,nU,oU) => dualSystem(oU,nU,0,"lb/h", unitConv.kgtolb(n)),
  barrel_flow:(n,d,nU,oU,spG = spGrav) => dualSystem(oU,nU,d,"x10³ BPD", 
    unitConv.kgtolb(n)/ unitConv.BPDtolb_h(1,spG) /1e3),  
  barrel_flowC:(n,d,nU,oU) => dualSystem(oU,nU,d,"BPD", n),
  vol_flow: (n,d,nU,oU) => dualSystem(oU,nU,d,"ft³/h", unitConv.mtoft(n)**3),
  cp:       (n,d,nU,oU) => dualSystem(oU,nU,d,"Btu/lb-°F", n *.238845896627),
  cp_mol:   (n,d,nU,oU) => dualSystem(oU,nU,d,"Btu/lb-mol-°F", n *.238845896627),
  power:    (n,d,nU,oU) => dualSystem(oU,nU,d,"Btu/h", n *3.4121416331),
  moist:    (n,d,nU,oU) => dualSystem(oU,nU,d,"÷10³ lb H2O/lb", n*1e3),
  thermal:  (n,d,nU,oU) => dualSystem(oU,nU,d,"BTU/h-ft-°F", 
    unitConv.kJtoBTU(n)/unitConv.KtoR()/unitConv.mtoft()),
  convect:  (n,d,nU,oU) => dualSystem(oU,nU,d,"BTU/h-ft²-°F", 
    unitConv.kJtoBTU(n)/unitConv.KtoR()/(unitConv.m2toft2())),
  viscosity:(n,d,nU,oU) => dualSystem(oU,nU,d,"cP", n),
  system:   {en: "English", es: "Inglés"}
};

const siSystem = {
  "energy/mol":   (n,d,nU,oU) => dualSystem(oU,nU,d,"kJ/mol", n),
  "mass/mol":     (n,d,nU,oU) => dualSystem(oU,nU,d,"kg/kmol", n),
  heat_flow:      (n,d,nU,oU) => dualSystem(oU,nU,d,"MW", n*1e-6 /3.6),
  heat_flux:      (n,d,nU,oU) => dualSystem(oU,nU,d,"W/m²", n /3600),
  fouling_factor: (n,d,nU,oU) => dualSystem(oU,nU,d,"m²-K/W ÷10³", n*3.6e3),

  "energy/mass":  (n,d,nU,oU) => dualSystem(oU,nU,d,"kJ/kg", n),
  "energy/vol":   (n,d,nU,oU) => dualSystem(oU,nU,d,"kJ/m³", n),
  area:       (n,d,nU,oU)  => dualSystem(oU,nU,d,"m²", n),
  length:     (n,d,nU,oU)  => dualSystem(oU,nU,d,"m", n),
  lengthC:    (n,d,nU,oU)  => dualSystem(oU,nU,d,"cm", n*1e2),
  lengthInv:  (n,d,nU,oU)  => dualSystem(oU,nU,d,"1/m", n),
  tempC:      (n,_d,nU,oU) => dualSystem(oU,nU,0,"°C", n -tempToK),
  temp:       (n,d,nU,oU)  => dualSystem(oU,nU,d,"K", n),
  pressure:   (n,d,nU,oU)  => dualSystem(oU,nU,d,"kPa", n *1e-3),
  mass:       (n,d,nU,oU)  => dualSystem(oU,nU,d,"kg", n *1e-3),
  mass_flow:  (n,d,nU,oU)  => dualSystem(oU,nU,d,"kg/s", n /3600),
  barrel_flow:(n,d,nU,oU,spG = spGrav) => englishSystem.barrel_flow(n,d,nU,oU,spG),
  barrel_flowC:(n,d,nU,oU) => dualSystem(oU,nU,d,"m³/d", n/unitConv.m3ToBarrels()),
  vol_flow: (n,d,nU,oU) => dualSystem(oU,nU,d,"m³/s", n /3600),
  cp:       (n,d,nU,oU) => dualSystem(oU,nU,d,"kJ/kg-K", n),
  cp_mol:   (n,d,nU,oU) => dualSystem(oU,nU,d,"kJ/kmol-K", n),
  power:    (n,d,nU,oU) => dualSystem(oU,nU,d,"W", n /3.6),
  moist:    (n,d,nU,oU) => dualSystem(oU,nU,d,"g H2O/kg", n *1e3),
  thermal:  (n,d,nU,oU) => dualSystem(oU,nU,d,"kJ/h-m-C", n),
  convect:  (n,d,nU,oU) => dualSystem(oU,nU,d,"kJ/h-m²-C", n),
  viscosity:(n,d,nU,oU) => dualSystem(oU,nU,d,"cP", n),
  system:   {en: "SI", es: "SI"}
};

const initSystem = (unitSystem) => {
  if (typeof unitSystem !== "string") {
    if (options.verbose) logger.warn( 
    `invalid type (${unitSystem}) for unit system, using default SI`);
    return siSystem
  }
  switch (unitSystem.toLowerCase()) {
    case "si":
      return siSystem;
    case "english":
      return englishSystem;
    case "en":
      return englishSystem;
    default:
      logger.warn(unitSystem.toLowerCase() + 
      ' - invalid unit system, using default SI')
      return siSystem;
  }
};

module.exports = {
  options,
  unitConv,
  newtonRaphson,
  logger,
  round,
  roundDict,
  linearApprox,
  viscosityApprox,
  initSystem,
  normalize,
  flueViscosity,
  flueThermalCond,
  kw_tubes_A312_TP321,
  LMTD
};
\end{verbatim}
